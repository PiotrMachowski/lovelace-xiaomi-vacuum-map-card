/* eslint-disable @typescript-eslint/no-explicit-any */
import { css, CSSResultGroup, html, LitElement, PropertyValues, svg, SVGTemplateResult, TemplateResult } from "lit";
import { customElement, property, query, queryAll, state } from "lit/decorators";
import { ActionHandlerEvent, forwardHaptic, LovelaceCard, LovelaceCardEditor } from "custom-card-helpers";

import "./editor";
import type {
    ActionableObjectConfig,
    IconActionConfig,
    LovelaceDomEvent,
    Point,
    PredefinedPointConfig,
    ReplacedKey,
    RoomConfig,
    RoomConfigEventData,
    TileConfig,
    XiaomiVacuumMapCardConfig,
} from "./types/types";
import {
    ActionHandlerFunction,
    ActionType,
    CalibrationPoint,
    CardPresetConfig,
    MapExtractorRoom,
    PredefinedZoneConfig,
    TranslatableString,
    VariablesStorage,
} from "./types/types";
import { actionHandler } from "./action-handler-directive";
import {
    CARD_CUSTOM_ELEMENT_NAME,
    CARD_VERSION,
    DISCONNECTED_IMAGE,
    DISCONNECTION_TIME,
    EDITOR_CUSTOM_ELEMENT_NAME,
    EMPTY_MAP_MODE,
    EVENT_AUTOGENERATED_CONFIG,
    EVENT_AUTOGENERATED_CONFIG_GET,
    EVENT_LOVELACE_DOM,
    EVENT_LOVELACE_DOM_DETAIL,
    EVENT_ROOM_CONFIG,
    EVENT_ROOM_CONFIG_GET,
    EVENT_SELECTION_CHANGED,
    EVENT_SERVICE_CALL,
    EVENT_SERVICE_CALL_GET,
} from "./const";
import { localize, localizeWithHass } from "./localize/localize";
import PinchZoom from "./pinch-zoom";
import "./pinch-zoom";
import { ManualRectangle } from "./model/map_objects/manual-rectangle";
import { Context } from "./model/map_objects/context";
import { ManualPoint } from "./model/map_objects/manual-point";
import { ManualPath } from "./model/map_objects/manual-path";
import {
    areConditionsMet,
    checkIfEntitiesChanged,
    conditional,
    createActionWithConfigHandler,
    delay,
    getMousePosition,
    getWatchedEntities,
    hasConfigOrAnyEntityChanged,
    stopEvent,
} from "./utils";
import { PredefinedPoint } from "./model/map_objects/predefined-point";
import { PredefinedMultiRectangle } from "./model/map_objects/predefined-multi-rectangle";
import { Room } from "./model/map_objects/room";
import { areAllEntitiesDefined, isOldConfig, validateConfig } from "./config-validators";
import { MapMode } from "./model/map_mode/map-mode";
import { SelectionType } from "./model/map_mode/selection-type";
import { RepeatsType } from "./model/map_mode/repeats-type";
import { GeneratorWrapper } from "./model/generators/generator-wrapper";
import { PlatformGenerator } from "./model/generators/platform-generator";
import { sortTiles, TilesGenerator } from "./model/generators/tiles-generator";
import { IconListGenerator, sortIcons } from "./model/generators/icon-list-generator";
import { ToastRenderer } from "./renderers/toast-renderer";
import { CoordinatesConverter } from "./model/map_objects/coordinates-converter";
import { MapObject } from "./model/map_objects/map-object";
import { MousePosition } from "./model/map_objects/mouse-position";
import { ServiceCallSchema } from "./model/map_mode/service-call-schema";
import { HomeAssistantFixed } from "./types/fixes";
import "./polyfills/objectEntries";
import "./polyfills/objectFromEntries";

import { DropdownMenu } from "./components/dropdown-menu";
import { TilesWrapper } from "./components/tiles-wrapper";
import { IconsWrapper } from "./components/icons-wrapper";
import { PresetSelector } from "./components/preset-selector";

const line1 = "   XIAOMI-VACUUM-MAP-CARD";
const line2 = `   ${localize("common.version")} ${CARD_VERSION}`;
const length = Math.max(line1.length, line2.length) + 3;
const pad = (text: string, length: number) => text + " ".repeat(length - text.length);
/* eslint no-console: 0 */
console.info(
    `%c${pad(line1, length)}\n%c${pad(line2, length)}`,
    "color: orange; font-weight: bold; background: black",
    "color: white; font-weight: bold; background: dimgray",
);

const windowWithCards = window as unknown as Window & { customCards: unknown[] };
windowWithCards.customCards = windowWithCards.customCards || [];
windowWithCards.customCards.push({
    type: CARD_CUSTOM_ELEMENT_NAME,
    name: "Vacuum Map Card",
    description: localize("common.description"),
});

@customElement(CARD_CUSTOM_ELEMENT_NAME)
export class XiaomiVacuumMapCard extends LitElement {
    @state() private oldConfig = false;
    @state() private config!: XiaomiVacuumMapCardConfig;
    @state() private presetIndex!: number;
    @state() private realScale!: number;
    @state() private realImageWidth!: number;
    @state() private realImageHeight!: number;
    @state() private mapScale!: number;
    @state() private mapX!: number;
    @state() private mapY!: number;
    @state() public repeats = 1;
    @state() private selectedMode = 0;
    @state() private mapLocked = false;
    @state() private configErrors: string[] = [];
    @state() private connected = false;
    @state() public internalVariables = {};
    @state() private mapViewBox?: DOMRect;
    @query(".modes-dropdown-menu") private _modesDropdownMenu?: HTMLElement;
    @queryAll(".icon-dropdown-menu") private _iconDropdownMenus?: NodeListOf<HTMLElement>;
    private currentPreset!: CardPresetConfig;
    private watchedEntities: string[] = [];
    private selectedManualRectangles: ManualRectangle[] = [];
    private selectedManualPoint?: ManualPoint;
    private selectedManualPath: ManualPath = new ManualPath([], this._getContext());
    private selectedPredefinedRectangles: PredefinedMultiRectangle[] = [];
    private selectedRooms: Room[] = [];
    private selectedPredefinedPoints: PredefinedPoint[] = [];
    private selectablePredefinedRectangles: PredefinedMultiRectangle[] = [];
    private selectableRooms: Room[] = [];
    private selectablePredefinedPoints: PredefinedPoint[] = [];
    private coordinatesConverter?: CoordinatesConverter;
    private entitiesToManuallyUpdate: string[] = [];
    private modes: MapMode[] = [];
    private shouldHandleMouseUp!: boolean;
    private lastHassUpdate!: Date;
    public isInEditor = false;

    constructor() {
        super();
        this._handleAutogeneratedConfigGet = this._handleAutogeneratedConfigGet.bind(this);
        this._handleRoomsConfigGet = this._handleRoomsConfigGet.bind(this);
        this._handleServiceCallGet = this._handleServiceCallGet.bind(this);
        this._handleLovelaceDomEvent = this._handleLovelaceDomEvent.bind(this);
    }

    @property({ attribute: false }) public _hass!: HomeAssistantFixed;

    public get hass(): HomeAssistantFixed {
        return this._hass;
    }

    public set hass(hass: HomeAssistantFixed) {
        const firstHass = !this._hass && hass;
        this._hass = hass;
        this.lastHassUpdate = new Date();
        if (firstHass) {
            this._firstHass();
        }
    }

    public static async getConfigElement(): Promise<LovelaceCardEditor> {
        return document.createElement(EDITOR_CUSTOM_ELEMENT_NAME);
    }

    public static getStubConfig(hass: HomeAssistantFixed): XiaomiVacuumMapCardConfig | undefined {
        const entities = Object.keys(hass.states);
        const cameras = entities
            .filter(e => ["camera", "image"].includes(e.substring(0, e.indexOf("."))))
            .filter(e => hass?.states[e].attributes["calibration_points"]);
        const vacuums = entities.filter(e => e.substring(0, e.indexOf(".")) === "vacuum");
        if (cameras.length === 0 || vacuums.length === 0) {
            return undefined;
        }
        return {
            type: "custom:" + CARD_CUSTOM_ELEMENT_NAME,
            map_source: {
                camera: cameras[0],
            },
            calibration_source: {
                camera: true,
            },
            entity: vacuums[0],
            vacuum_platform: PlatformGenerator.XIAOMI_MIIO_PLATFORM,
        };
    }

    public setConfig(config: XiaomiVacuumMapCardConfig): void {
        if (!config) {
            throw new Error(this._localize("common.invalid_configuration"));
        }
        this.config = config;
        if (isOldConfig(config)) {
            this.oldConfig = true;
            return;
        }
        this.configErrors = validateConfig(this.config);
        if (this.configErrors.length > 0) {
            return;
        }
        this.watchedEntities = getWatchedEntities(this.config);
        this._setPresetIndex(0, false, true);
        this.requestUpdate("config");
    }

    public getCardSize(): number {
        return 12;
    }

    connectedCallback(): void {
        super.connectedCallback();
        if (this._isInEditor()) {
            window.addEventListener(EVENT_AUTOGENERATED_CONFIG_GET, this._handleAutogeneratedConfigGet);
            window.addEventListener(EVENT_ROOM_CONFIG_GET, this._handleRoomsConfigGet);
            window.addEventListener(EVENT_SERVICE_CALL_GET, this._handleServiceCallGet)
            this.isInEditor = true;
        }
        document.addEventListener(EVENT_LOVELACE_DOM, this._handleLovelaceDomEvent);
        this.connected = true;
        this._updateElements();
        delay(100).then(() => this.requestUpdate());
    }

    disconnectedCallback(): void {
        super.disconnectedCallback();
        if (this._isInEditor()) {
            window.removeEventListener(EVENT_AUTOGENERATED_CONFIG_GET, this._handleAutogeneratedConfigGet);
            window.removeEventListener(EVENT_ROOM_CONFIG_GET, this._handleRoomsConfigGet);
            window.removeEventListener(EVENT_SERVICE_CALL_GET, this._handleServiceCallGet);
        }
        document.removeEventListener(EVENT_LOVELACE_DOM, this._handleLovelaceDomEvent);
        this.connected = false;
    }

    protected shouldUpdate(changedProps: PropertyValues): boolean {
        if (!this.config) {
            return false;
        }
        return hasConfigOrAnyEntityChanged(this.watchedEntities, changedProps, false, this.hass);
    }

    protected render(): TemplateResult | void {
        if (this.oldConfig) {
            return this._showOldConfig();
        }
        if (this.configErrors.length > 0) {
            return this._showConfigErrors(this.configErrors);
        }
        const invalidEntities = areAllEntitiesDefined(this.watchedEntities, this.hass);
        if (invalidEntities.length > 0) {
            return this._showInvalidEntities(invalidEntities);
        }

        let preset = this._getCurrentPreset();
        const allPresets = this._getAllPresets();
        let availablePresets = this._getAllAvailablePresets();
        let availablePresetIndex = availablePresets.indexOf(allPresets[this.presetIndex]);
        if (availablePresetIndex === -1) {
            this._firstHass();
            preset = this._getCurrentPreset();
            availablePresets = this._getAllAvailablePresets();
            availablePresetIndex = availablePresets.indexOf(allPresets[this.presetIndex]);
        }
        this._updateCalibration(preset);

        const tiles = preset.tiles?.filter(tile => areConditionsMet(tile, this.internalVariables, this.hass));
        const icons = IconsWrapper.preprocessIcons(preset.icons, this.internalVariables, this.hass);
        const modes = this.modes;

        const mapSrc = this._getMapSrc(preset);
        const validCalibration = !!this.coordinatesConverter && this.coordinatesConverter.calibrated;
        const mapControls = validCalibration ? this._createMapControls() : [];

        const mapZoomerContent = html`
            <div
                id="map-zoomer-content"
                style="
                 margin-top: ${(preset.map_source.crop?.top ?? 0) * -1}px;
                 margin-bottom: ${(preset.map_source.crop?.bottom ?? 0) * -1}px;
                 margin-left: ${(preset.map_source.crop?.left ?? 0) * -1}px;
                 margin-right: ${(preset.map_source.crop?.right ?? 0) * -1}px;">
                ${conditional(
                    this._isSvgMapImage(),
                    () => html`<object id="map-object" data="${mapSrc}" width="0" height="0" type="image/svg+xml" @load="${() => this._updateImageSizeAndScale()}"></object>`
                )}
                <img 
                    id="map-image"
                    alt="camera_image"
                    class="${this.mapScale * this.realScale > 1 ? "zoomed" : ""}"
                    src="${mapSrc}"
                    @load="${() => this._updateImageSizeAndScale()}"
                    />
                <div id="map-image-overlay">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        version="2.0"
                        id="svg-wrapper"
                        width="100%"
                        height="100%"
                        @mousedown="${(e: MouseEvent): void => this._mouseDown(e)}"
                        @mousemove="${(e: MouseEvent): void => this._mouseMove(e)}"
                        @mouseup="${(e: PointerEvent): void => this._mouseUp(e)}">
                        ${validCalibration ? this._drawSelection() : null}
                    </svg>
                </div>
            </div>
        `;
        return html`
            <ha-card style="--map-scale: ${this.mapScale}; --real-scale: ${this.realScale};">
                ${conditional(
                    (this.config.title ?? "").length > 0,
                    () => html`<h1 class="card-header">${this.config.title}</h1>`,
                )}
                <xvmc-preset-selector
                    .availablePresets=${availablePresets}
                    .availablePresetIndex=${availablePresetIndex}
                    .openPreviousPreset=${(): void => this._openPreviousPreset()}
                    .previousPresetIndex=${this._getPreviousPresetIndex()}
                    .presetActivable=${preset.activate !== undefined}
                    .presetName=${preset.preset_name}
                    .executePresetsActivation=${(): void => this._executePresetsActivation()}
                    .openNextPreset=${(): void => this._openNextPreset()}
                    .nextPresetIndex=${this._getNextPresetIndex()}>
                </xvmc-preset-selector>
                <div class="map-wrapper">
                    <pinch-zoom
                        min-scale="0.5"
                        id="map-zoomer"
                        @change="${this._calculateScale}"
                        two-finger-pan="${preset.two_finger_pan}"
                        locked="${this.mapLocked}"
                        no-default-pan="${this.mapLocked || preset.two_finger_pan}"
                        style="touch-action: none;">
                        ${mapZoomerContent}
                    </pinch-zoom>
                    <div id="map-zoomer-overlay">
                        <div style="right: 0; top: 0; position: absolute;">
                            <ha-icon
                                icon="${this.mapLocked ? "mdi:lock" : "mdi:lock-open"}"
                                class="standalone-icon-on-map clickable ripple"
                                @click="${this._toggleLock}"></ha-icon>
                        </div>
                        <div class="map-zoom-icons" style="visibility: ${this.mapLocked ? "hidden" : "visible"}">
                            <ha-icon
                                icon="mdi:image-filter-center-focus"
                                class="icon-on-map clickable ripple"
                                @click="${this._restoreMap}"></ha-icon>
                            <div class="map-zoom-icons-main">
                                <ha-icon
                                    icon="mdi:magnify-minus"
                                    class="icon-on-map clickable ripple"
                                    @click="${this._zoomOut}"></ha-icon>
                                <ha-icon
                                    icon="mdi:magnify-plus"
                                    class="icon-on-map clickable ripple"
                                    @click="${this._zoomIn}"></ha-icon>
                            </div>
                        </div>
                    </div>
                </div>
                ${conditional(!validCalibration, () => this._showInvalidCalibrationWarning())}
                ${conditional(
                    modes.length > 1 || mapControls.length > 0 || (icons?.length??0) !== 0 || (tiles?.length ?? 0) !== 0,
                    () => html`
                    <div class="controls-wrapper">
                        ${conditional(
                            validCalibration && (modes.length > 1 || mapControls.length > 0),
                            () => html`
                                <div class="map-controls-wrapper">
                                    <div class="map-controls">
                                        ${conditional(modes.length > 1, () => html`
                                            <xvmc-dropdown-menu
                                                .values=${modes}
                                                .currentIndex=${this.selectedMode}
                                                .setValue=${selected => this._setCurrentMode(selected)}
                                                .renderNameCollapsed=${true}>
                                            </xvmc-dropdown-menu>
                                            `,
                                        )}
                                        ${conditional(
                                            mapControls.length > 0,
                                            () => html` <div class="map-actions-list">${mapControls}</div> `,
                                        )}
                                    </div>
                                </div>
                            `,
                        )}
                        <xvmc-icons-wrapper
                            .icons=${icons}
                            .isInEditor=${this.isInEditor}
                            .onAction=${(c: ActionableObjectConfig, action?: string) => createActionWithConfigHandler(this, c, action)}>
                        </xvmc-icons-wrapper>
                        <xvmc-tiles-wrapper
                            .hass=${this.hass}
                            .tiles=${tiles}
                            .isInEditor=${this.isInEditor}
                            .onAction=${(c: ActionableObjectConfig, action?: string) => createActionWithConfigHandler(this, c, action)}
                            .internalVariables=${this.internalVariables}>
                        </xvmc-tiles-wrapper>
                    </div>`
                )}
                ${ToastRenderer.render("map-card")}
            </ha-card>
        `;
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    protected updated(changedProperties: PropertyValues): void {
        const oldHass = changedProperties.get("_hass") as HomeAssistantFixed | undefined;
        const changed = oldHass && this.hass && checkIfEntitiesChanged(this.entitiesToManuallyUpdate, oldHass, this.hass);
        this._updateElements(changed);
    }

    public _getCurrentPreset(): CardPresetConfig {
        return this.currentPreset;
    }

    private _getCalibration(config: CardPresetConfig): CalibrationPoint[] | undefined {
        if (config.calibration_source?.identity) {
            return [
                { map: { x: 0, y: 0 }, vacuum: { x: 0, y: 0 } },
                { map: { x: 1, y: 0 }, vacuum: { x: 1, y: 0 } },
                { map: { x: 0, y: 1 }, vacuum: { x: 0, y: 1 } },
            ];
        }
        if (
            config.calibration_source?.calibration_points &&
            [3, 4].includes(config.calibration_source.calibration_points.length)
        ) {
            return config.calibration_source.calibration_points;
        }
        if (!this.hass) {
            return undefined;
        }
        if (config.calibration_source?.entity && !config.calibration_source?.attribute) {
            return JSON.parse(this.hass.states[config.calibration_source.entity]?.state);
        }
        if (config.calibration_source?.entity && config.calibration_source?.attribute) {
            return this.hass.states[config.calibration_source.entity]?.attributes[config.calibration_source.attribute];
        }
        if (config.calibration_source?.camera) {
            return this.hass.states[config.map_source?.camera ?? ""]?.attributes["calibration_points"];
        }
        if (config.calibration_source?.platform) {
            return PlatformGenerator.getCalibration(config.calibration_source.platform);
        }
        const platformCalibration = PlatformGenerator.getCalibration(config.vacuum_platform);
        if (platformCalibration) {
            return platformCalibration;
        }
        return undefined;
    }

    private _firstHass(): void {
        if (this.configErrors.length === 0 && !this.oldConfig) {
            const allPresets = this._getAllPresets();
            const allAvailablePresets = this._getAllAvailablePresets();
            const index = allPresets.indexOf(allAvailablePresets[0]);
            this._setPresetIndex(index, false, true);
        }
    }

    private _getAllPresets(): CardPresetConfig[] {
        return [this.config, ...(this.config.additional_presets ?? [])];
    }

    private _getAllAvailablePresets(): CardPresetConfig[] {
        const allPresets = this._getAllPresets();
        const available = allPresets.filter(
            p => (p.conditions?.length ?? 0) === 0 || areConditionsMet(p, this.internalVariables, this.hass),
        );
        return available.length === 0 ? [allPresets[0]] : available;
    }

    private _getPreviousPresetIndex(): number {
        const allPresets = this._getAllPresets();
        const previousPresets = allPresets.filter(
            (p, i) =>
                i < this.presetIndex &&
                ((p.conditions?.length ?? 0) === 0 || areConditionsMet(p, this.internalVariables, this.hass)),
        );
        if (previousPresets.length == 0) return -1;
        return allPresets.indexOf(previousPresets[previousPresets.length - 1]);
    }

    private _getNextPresetIndex(): number {
        const allPresets = this._getAllPresets();
        const previousPresets = allPresets.filter(
            (p, i) =>
                i > this.presetIndex &&
                ((p.conditions?.length ?? 0) === 0 || areConditionsMet(p, this.internalVariables, this.hass)),
        );
        if (previousPresets.length == 0) return -1;
        return allPresets.indexOf(previousPresets[0]);
    }

    private _openPreviousPreset(): void {
        const index = this._getPreviousPresetIndex();
        if (index >= 0) {
            this._setPresetIndex(index, true);
        }
    }

    private _openNextPreset(): void {
        const index = this._getNextPresetIndex();
        if (index >= 0) {
            this._setPresetIndex(index, true);
        }
    }

    private _setPresetIndex(index: number, user = false, force = false): void {
        index = Math.min(Math.max(index, 0), this.config.additional_presets?.length ?? 0);
        if (index === this.presetIndex && !force) {
            return;
        }
        const config = index === 0 ? this.config : (this.config.additional_presets ?? [])[index - 1];
        if (!this.mapLocked) this._getPinchZoom()?.setTransform({ scale: 1, x: 0, y: 0, allowChangeEvent: true });
        if (user) {
            forwardHaptic("selection");
        }
        this.mapLocked = config?.map_locked ?? false;
        this.selectedMode = 0;
        this.realScale = 1;
        this.mapScale = 1;
        this.mapX = 0;
        this.mapY = 0;
        if (this.hass) this._updateCalibration(config);
        this.modes = this._getModes(config);

        this.presetIndex = index;
        this.currentPreset = config;
        this.internalVariables = this._getInternalVariables(config);

        this._getIconsAndTiles(config, this.internalVariables)
            .then(([icons, tiles]) => this._setPreset({ ...config, tiles: tiles, icons: icons }))
            .then(() => setTimeout(() => this.requestUpdate(), 100))
            .then(() => this._setCurrentMode(0, false));

        if (user && this.currentPreset.activate_on_switch) {
            this._executePresetsActivation();
        }
        this._selectionChanged();
    }

    private _getInternalVariables(config: CardPresetConfig): VariablesStorage {
        return {
            ...(PlatformGenerator.getVariables(config.vacuum_platform) ?? {}),
            ...(config.internal_variables ?? {}),
        };
    }

    private _getIconsAndTiles(
        config: CardPresetConfig,
        internalVariables: VariablesStorage
    ): Promise<[IconActionConfig[], TileConfig[]]> {
        const vacuumPlatform = PlatformGenerator.getPlatformName(config.vacuum_platform);
        const iconsPromise = GeneratorWrapper.generate(this.hass, config.icons, config.entity, vacuumPlatform,
            internalVariables, this.config.language, config.append_icons ?? false,
            (t: IconActionConfig) => t.icon_id, sortIcons, IconListGenerator.generate);
        const tilesPromise = GeneratorWrapper.generate(this.hass, config.tiles, config.entity, vacuumPlatform,
            internalVariables, this.config.language, config.append_tiles ?? false, (t: TileConfig) => t.tile_id,
            sortTiles, TilesGenerator.generate);
        return Promise.all([iconsPromise, tilesPromise]);
    }

    private _getModes(config: CardPresetConfig) {
        const vacuumPlatform = PlatformGenerator.getPlatformName(config.vacuum_platform);
        return (
            (config.map_modes?.length ?? -1) === -1 || vacuumPlatform.startsWith("Setup")
                ? PlatformGenerator.generateDefaultModes(vacuumPlatform)
                : config.map_modes ?? [EMPTY_MAP_MODE]
        ).map(m => new MapMode(vacuumPlatform, m, this.config.language));
    }

    private _executePresetsActivation() {
        if (this.currentPreset.activate) {
            const schema = new ServiceCallSchema(this.currentPreset.activate);
            const serviceCall = schema.apply(this.currentPreset.entity, [], 0, {});
            this.hass
                .callService(serviceCall.domain, serviceCall.service, serviceCall.serviceData, serviceCall.target)
                .then(() => forwardHaptic("success"));
        }
    }

    private _setPreset(config: CardPresetConfig): void {
        this.currentPreset = config;
        this.watchedEntities = getWatchedEntities({type: "", ...config});
    }

    private _updateCalibration(config: CardPresetConfig): void {
        this.coordinatesConverter = undefined;
        const calibrationPoints = this._getCalibration(config);
        this.coordinatesConverter = new CoordinatesConverter(calibrationPoints, this._getOffset());
    }

    private _getMapSrc(config: CardPresetConfig): string {
        if (config.map_source.camera) {
            if (
                this.connected &&
                this.lastHassUpdate &&
                this.lastHassUpdate.getTime() + DISCONNECTION_TIME >= new Date().getTime()
            ) {
                const url = this.hass.hassUrl(this.hass.states[config.map_source.camera].attributes.entity_picture);
                return `${url}&v=${+new Date()}`;
            }
            return DISCONNECTED_IMAGE;
        }
        if (config.map_source.image) {
            return `${config.map_source.image}`;
        }
        return DISCONNECTED_IMAGE;
    }

    private _createMapControls(): TemplateResult[] {
        const controls: TemplateResult[] = [];
        const currentMode = this._getCurrentMode();
        if (!currentMode) {
            return [];
        }
        if (currentMode.selectionType === SelectionType.MANUAL_RECTANGLE) {
            controls.push(html`
                <paper-button class="map-actions-item clickable ripple" @click="${(): void => this._addRectangle()}">
                    <ha-icon icon="mdi:plus"></ha-icon>
                </paper-button>
            `);
        }
        if (currentMode.selectionType === SelectionType.MANUAL_PATH) {
            controls.push(html`
                <paper-button
                    class="map-actions-item clickable ripple"
                    @click="${(): void => {
                        this.selectedManualPath.removeLast();
                        forwardHaptic("selection");
                        this._selectionChanged();
                        this.requestUpdate();
                    }}">
                    <ha-icon icon="mdi:undo-variant"></ha-icon>
                </paper-button>
                <paper-button
                    class="map-actions-item clickable ripple"
                    @click="${(): void => {
                        this.selectedManualPath.clear();
                        forwardHaptic("selection");
                        this._selectionChanged();
                        this.requestUpdate();
                    }}">
                    <ha-icon icon="mdi:delete-empty"></ha-icon>
                </paper-button>
            `);
        }
        if (currentMode.repeatsType !== RepeatsType.NONE) {
            controls.push(html`
                <paper-button
                    class="map-actions-item clickable ripple"
                    @click="${(): void => {
                        this.repeats = (this.repeats % currentMode.maxRepeats) + 1;
                        this._selectionChanged();
                        forwardHaptic("selection");
                    }}">
                    <div>×${this.repeats}</div>
                </paper-button>
            `);
        }
        if (!currentMode.runImmediately) {
            controls.push(html`
                <paper-button
                    class="map-actions-item main clickable ripple"
                    @action="${this._handleRunAction()}"
                    .actionHandler="${actionHandler({
                        hasHold: true,
                        hasDoubleClick: true,
                    })}">
                    <ha-icon icon="mdi:play"></ha-icon>
                    <ha-icon
                        icon="${currentMode.icon}"
                        style="position: absolute; transform: scale(0.5) translate(15px, -20px)"></ha-icon>
                </paper-button>
            `);
        }

        return controls;
    }

    private _getContext(): Context {
        return new Context(
            () => this.mapScale,
            () => this.realScale,
            event => this._getMousePosition(event),
            () => this.requestUpdate(),
            () => this._selectionChanged(),
            () => this.coordinatesConverter,
            () => this.selectedManualRectangles,
            () => this.selectedPredefinedRectangles,
            () => this.selectedRooms,
            () => this.selectedPredefinedPoints,
            () => this._getCurrentMode()?.coordinatesRounding ?? false,
            () => this._getCurrentMode()?.coordinatesToMetersDivider ?? 1,
            () => this._getCurrentMode()?.maxSelections ?? 0,
            property => this._getCssProperty(property),
            () => this._runImmediately(),
            string => this._localize(string),
            entity => this._hass.states[entity].state,
            entity => this._hass.callService("homeassistant", "toggle", {"entity_id": entity}),
        );
    }

    private _getMousePosition(event: MouseEvent | TouchEvent): MousePosition {
        return getMousePosition(event, this._getSvgWrapper(), this.mapScale);
    }

    private _setCurrentMode(newModeIndex: number, manual = true): void {
        const newMode = this.modes[newModeIndex];
        this.selectedManualRectangles = [];
        this.selectedManualPoint = undefined;
        this.selectedManualPath.clear();
        this.selectedPredefinedRectangles = [];
        this.selectedRooms = [];
        this.selectedPredefinedPoints = [];
        this.selectablePredefinedRectangles = [];
        this.selectableRooms = [];
        this.selectablePredefinedPoints = [];

        switch (newMode?.selectionType) {
            case SelectionType.PREDEFINED_RECTANGLE:
                const zonesFromEntities = PredefinedMultiRectangle.getFromEntities(newMode, this.hass, () =>
                    this._getContext(),
                );
                const manualZones = newMode.predefinedSelections
                    .map(ps => ps as PredefinedZoneConfig)
                    .filter(pzc => typeof pzc.zones !== "string")
                    .map(pzc => new PredefinedMultiRectangle(pzc, this._getContext()));
                this.selectablePredefinedRectangles = zonesFromEntities.concat(manualZones);
                this.selectedPredefinedRectangles = this.selectablePredefinedRectangles.filter(s => s.selected);
                this.entitiesToManuallyUpdate = newMode.predefinedSelections
                    .filter(s => s.state_entity)
                    .map(s => s.state_entity as string);
                break;
            case SelectionType.ROOM:
                this.selectableRooms = newMode.predefinedSelections.map(
                    ps => new Room(ps as RoomConfig, this._getContext()),
                );
                this.selectedRooms = this.selectableRooms.filter(s => s.selected);
                this.entitiesToManuallyUpdate = newMode.predefinedSelections
                    .filter(s => s.state_entity)
                    .map(s => s.state_entity as string);
                break;
            case SelectionType.PREDEFINED_POINT:
                const pointsFromEntities = PredefinedPoint.getFromEntities(newMode, this.hass, () =>
                    this._getContext(),
                );
                const manualPoints = newMode.predefinedSelections
                    .map(ps => ps as PredefinedPointConfig)
                    .filter(ppc => typeof ppc.position !== "string")
                    .map(ppc => new PredefinedPoint(ppc, this._getContext()));
                this.selectablePredefinedPoints = pointsFromEntities.concat(manualPoints);
                this.selectedPredefinedPoints = this.selectablePredefinedPoints.filter(s => s.selected);
                this.entitiesToManuallyUpdate = newMode.predefinedSelections
                    .filter(s => s.state_entity)
                    .map(s => s.state_entity as string);
                break;
        }
        if (this.selectedMode != newModeIndex && manual) forwardHaptic("selection");
        this.selectedMode = newModeIndex;
        this._selectionChanged();
    }

    public _getCurrentMode(): MapMode | undefined {
        return this.modes[this.selectedMode];
    }

    public _getSelection(mode: MapMode | undefined): { selection: unknown[]; variables: VariablesStorage } {
        if (!mode) {
            return { selection: [], variables: {} };
        }
        const repeats = mode.repeatsType === RepeatsType.INTERNAL ? this.repeats : null;
        let selection: unknown[] = [];
        let variables: VariablesStorage = {};
        const variablesExtractor = (mos: Array<MapObject | undefined>): VariablesStorage => ({
            ...(mos[0]?.variables ?? {}),
            variables: mos.map(r => r?.variables ?? {}),
        });
        switch (mode.selectionType) {
            case SelectionType.MANUAL_RECTANGLE:
                selection = this.selectedManualRectangles.map(r => r.toVacuum(repeats));
                variables = variablesExtractor(this.selectedManualRectangles);
                break;
            case SelectionType.PREDEFINED_RECTANGLE:
                selection = this.selectedPredefinedRectangles
                    .map(r => r.toVacuum(repeats))
                    .reduce((a, v) => a.concat(v), [] as unknown[]);
                variables = this.selectedPredefinedRectangles[0]?.variables ?? {};
                variables = variablesExtractor(this.selectedPredefinedRectangles);
                break;
            case SelectionType.ROOM:
                const selectedRooms = this.selectedRooms
                    .map(r => r.toVacuum())
                    .map(r => XiaomiVacuumMapCard.adjustRoomId(r, mode));
                selection = [...selectedRooms, ...(repeats && selectedRooms.length > 0 ? [repeats] : [])];
                variables = this.selectedRooms[0]?.variables ?? {};
                variables = variablesExtractor(this.selectedRooms);
                break;
            case SelectionType.MANUAL_PATH:
                selection = this.selectedManualPath.toVacuum(repeats);
                variables = this.selectedManualPath.variables ?? {};
                variables = variablesExtractor([this.selectedManualPath]);
                break;
            case SelectionType.MANUAL_POINT:
                selection = this.selectedManualPoint?.toVacuum(repeats) ?? [];
                variables = variablesExtractor([this.selectedManualPoint]);
                break;
            case SelectionType.PREDEFINED_POINT:
                selection = this.selectedPredefinedPoints
                    .map(p => p.toVacuum(repeats))
                    .reduce((a, v) => a.concat(v), [] as unknown[]);
                variables = variablesExtractor(this.selectedPredefinedPoints);
                break;
        }
        if (mode.repeatsType === RepeatsType.REPEAT) {
            selection = Array(this.repeats)
                .fill(0)
                .flatMap(() => selection);
        }
        return { selection, variables };
    }

    private async _runImmediately(): Promise<boolean> {
        if (this._getCurrentMode()?.runImmediately ?? false) {
            await this._run(false);
            return true;
        }
        return false;
    }

    private _selectionChanged(): void {
        const currentMode = this._getCurrentMode();
        const { selection } = this._getSelection(currentMode);

        if (this.isInEditor) {
            const event = new Event(EVENT_SELECTION_CHANGED);
            (event as any).selection = selection ?? "[]";
            window.dispatchEvent(event);
        }
    }

    private _isInEditor(): boolean {
        function isInEditor(e: Element): boolean {
            return (e.parentElement?.tagName?.toLowerCase() === "hui-card" && "preview" in (e.parentElement?.attributes ?? []))
                || (e.parentElement?.tagName?.toLowerCase() === "hui-section" && "preview" in (e.parentElement?.attributes ?? []))
                || e.parentElement?.tagName?.toLowerCase() === "hui-card-preview"
                || e.parentElement != null && isInEditor(e.parentElement)
                || e.parentNode?.toString() == "[object ShadowRoot]" && isInEditor((e.getRootNode() as ShadowRoot).host);
        }
        return isInEditor(this);
    }

    private async _handleAutogeneratedConfigGet(): Promise<void> {
        const event = new Event(EVENT_AUTOGENERATED_CONFIG);
        const additionalPresets = await Promise.all((this.config.additional_presets ?? [])
            .map(async p => await this._getConfigOfPreset(p)));
        (event as any).presetConfig = {
            ...this.config,
            ...await this._getConfigOfPreset(this.config),
            additional_presets: additionalPresets,
        };
        window.dispatchEvent(event);
    }

    private async _getConfigOfPreset(preset: CardPresetConfig): Promise<CardPresetConfig> {
        const internalVariables = this._getInternalVariables(preset)
        const [icons, tiles] = await this._getIconsAndTiles(preset, internalVariables);
        return {
            ...preset,
            icons: JSON.parse(JSON.stringify(icons)),
            tiles: JSON.parse(JSON.stringify(tiles)),
            map_modes: this._getModes(preset).map(m => m.toMapModeConfig()),
        };
    }

    private _handleRoomsConfigGet(): void {
        const event = new Event(EVENT_ROOM_CONFIG);
        (event as any).roomConfig = this._getRoomsConfig();
        window.dispatchEvent(event);
    }

    private async _handleServiceCallGet(): Promise<void> {
        const currentPreset = this._getCurrentPreset();
        const currentMode = this._getCurrentMode();
        const { selection, variables } = this._getSelection(currentMode);
        if ((selection as any[]).length == 0 || !currentMode) {
            this._showToast("popups.no_selection", "mdi:close", false);
            forwardHaptic("failure");
        } else {
            const serviceCall = await currentMode.getServiceCall(
                this.hass,
                currentPreset.entity,
                selection,
                this.repeats,
                { ...this.internalVariables, ...variables },
            );
            const event = new Event(EVENT_SERVICE_CALL);
            (event as any).serviceCall = JSON.stringify(serviceCall, null, 2);
            window.dispatchEvent(event);
        }
    }

    private async _handleLovelaceDomEvent(e: Event): Promise<void> {
        const lovelaceEvent = e as LovelaceDomEvent;
        if (
            EVENT_LOVELACE_DOM_DETAIL in lovelaceEvent.detail &&
            "action_handler_id" in lovelaceEvent.detail[EVENT_LOVELACE_DOM_DETAIL] &&
            lovelaceEvent.detail[EVENT_LOVELACE_DOM_DETAIL]["action_handler_id"]
            === (this.config.action_handler_id ?? "this")
        ) {
            const details = lovelaceEvent.detail[EVENT_LOVELACE_DOM_DETAIL];
            if (details["action"] === undefined)
                return;
            const action = details["action"] as ActionType;
            const data = details["data"];
            const currentMode = this._getCurrentMode();
            switch (action) {
                case ActionType.CLEANING_START:
                    await this._run(false);
                    break;
                case ActionType.INTERNAL_VARIABLE_SET:
                    this._setInternalVariable(data["variable"], data["value"]);
                    break;
                case ActionType.MAP_MODE_NEXT:
                    this._setCurrentMode((this.selectedMode + 1) % this.modes.length, false);
                    break;
                case ActionType.MAP_MODE_PREVIOUS:
                    this._setCurrentMode((this.selectedMode - 1 + this.modes.length) % this.modes.length, false);
                    break;
                case ActionType.MAP_MODE_SET:
                    this._setCurrentMode(data["index"] % this.modes.length, false);
                    break;
                case ActionType.REPEATS_DECREMENT:
                    if (currentMode) {
                        this.repeats = ((this.repeats + currentMode.maxRepeats - 2) % currentMode.maxRepeats) + 1;
                    }
                    break;
                case ActionType.REPEATS_INCREMENT:
                    if (currentMode) {
                        this.repeats = (this.repeats % currentMode.maxRepeats) + 1;
                    }
                    break;
                case ActionType.REPEATS_SET:
                    if (currentMode) {
                        this.repeats = ((data["value"] + currentMode.maxRepeats - 1) % currentMode.maxRepeats) + 1;
                    }
                    break;
                case ActionType.SELECTION_CLEAR:
                    this._setCurrentMode(this.selectedMode);
                    break;
            }
        }
    }

    private _setInternalVariable(variable: string, value: ReplacedKey) {
        const newValues = { ...this.internalVariables };
        newValues[variable] = value;
        this.internalVariables = newValues;
        this.requestUpdate();
    }

    private _getRoomsConfig(): RoomConfigEventData | undefined {
        const config = this._getCurrentPreset();
        const rooms = this.hass.states[config.map_source?.camera ?? ""]?.attributes["rooms"] as Record<
            string,
            MapExtractorRoom
        >;
        const roomsConfig = new Array<RoomConfig>();
        if (rooms) {
            const mode = this.modes.filter(m => m.selectionType === SelectionType.ROOM).reverse()[0];
            const modeIndex = mode ? this.modes.indexOf(mode) : -1;
            for (const room_id in rooms) {
                if (!rooms.hasOwnProperty(room_id)) continue;
                const room = rooms[room_id];
                if(!room.outline && !room.x0 && !room.y0 && !room.x1 && !room.y1)
                    continue;
                const outline = room.outline ?? [
                    [room.x0, room.y0],
                    [room.x1, room.y0],
                    [room.x1, room.y1],
                    [room.x0, room.y1],
                ];
                const keepFloat = outline.toString().includes(".");
                const formatCoord = (v: number, divide = 1): number =>
                    keepFloat ? v / divide : Math.round(v / divide);
                const x = outline.reduce((a, v) => a + (v[0] ?? 0), 0);
                const y = outline.reduce((a, v) => a + (v[1] ?? 0), 0);

                const roomConfig = {
                    id: room_id,
                    icon: {
                        name: room.icon ?? "mdi:broom",
                        x: room.x ?? formatCoord(x, outline.length),
                        y: room.y ?? formatCoord(y, outline.length),
                    },
                    label: {
                        text: room.name ?? `Room ${room_id}`,
                        x: room.x ?? formatCoord(x, outline.length),
                        y: room.y ?? formatCoord(y, outline.length),
                        offset_y: 35,
                    },
                    outline: outline,
                } as RoomConfig;
                roomsConfig.push(roomConfig);
            }
            return { modeIndex: modeIndex, rooms: roomsConfig };
        }
        return undefined;
    }

    private static adjustRoomId(roomId: string | number, config: MapMode): string | number {
        if (config.idType === "number") {
            const roomIdAsNumber = +roomId;
            return isNaN(roomIdAsNumber) ? roomId : roomIdAsNumber;
        }
        return roomId;
    }

    private async _run(debug: boolean): Promise<void> {
        const currentPreset = this._getCurrentPreset();
        const currentMode = this._getCurrentMode();
        const { selection, variables } = this._getSelection(currentMode);
        if ((selection as any[]).length == 0 || !currentMode) {
            this._showToast("popups.no_selection", "mdi:close", false);
            forwardHaptic("failure");
        } else {
            const repeats = this.repeats;
            const serviceCall = await currentMode.getServiceCall(this.hass, currentPreset.entity, selection, repeats, {
                ...this.internalVariables,
                ...variables,
            });
            if (debug || (this.config.debug ?? false)) {
                const message = JSON.stringify(serviceCall, null, 2);
                this._showToast("popups.success", "mdi:check", true);
                console.log(message);
                window.alert(message);
                forwardHaptic("success");
            } else {
                this.hass
                    .callService(serviceCall.domain, serviceCall.service, serviceCall.serviceData, serviceCall.target)
                    .then(
                        () => {
                            this._showToast("popups.success", "mdi:check", true);
                            forwardHaptic("success");
                        },
                        e => {
                            this._showToast("popups.failed", "mdi:close", false, e.message);
                            forwardHaptic("failure");
                        },
                    );
            }
        }
        if (currentPreset.clean_selection_on_start ?? true) {
            this._setCurrentMode(this.selectedMode);
        }
        this._selectionChanged();
    }

    private _updateElements(somethingChanged = false): void {
        const s = this._modesDropdownMenu?.shadowRoot?.querySelector(".dropdown-content") as HTMLElement;
        if (s) {
            s.style.borderRadius = this._getCssProperty("--map-card-internal-big-radius");
        }
        delay(100).then(() => this._calculateBasicScale());

        if (!somethingChanged) {
            return;
        }

        const update = () => {
            this._setCurrentMode(this.selectedMode);
            this.requestUpdate();
        };

        switch (this._getCurrentMode()?.selectionType) {
            case SelectionType.PREDEFINED_RECTANGLE:
                this.selectablePredefinedRectangles.filter(p => p.isDynamic()).length > 0 && update();
                break;
            case SelectionType.ROOM:
                this.selectedRooms.filter(p => p.isDynamic()).length > 0 && update();
                break;
            case SelectionType.PREDEFINED_POINT:
                this.selectablePredefinedPoints.filter(p => p.isDynamic()).length > 0 && update();
                break;
        }
    }

    private _drawSelection(): SVGTemplateResult | null {
        switch (this._getCurrentMode()?.selectionType) {
            case SelectionType.MANUAL_RECTANGLE:
                return svg`${this.selectedManualRectangles.map(r => r.render())}`;
            case SelectionType.PREDEFINED_RECTANGLE:
                return svg`${this.selectablePredefinedRectangles.map(r => r.render())}`;
            case SelectionType.ROOM:
                return svg`${this.selectableRooms.map(r => r.render())}`;
            case SelectionType.MANUAL_PATH:
                return svg`${this.selectedManualPath?.render()}`;
            case SelectionType.MANUAL_POINT:
                return svg`${this.selectedManualPoint?.render()}`;
            case SelectionType.PREDEFINED_POINT:
                return svg`${this.selectablePredefinedPoints.map(p => p.render())}`;
            default:
                return null;
        }
    }

    private _toggleLock(): void {
        this.mapLocked = !this.mapLocked;
        forwardHaptic("selection");
        delay(500).then(() => this.requestUpdate());
    }

    private _addRectangle(): void {
        const preset = this._getCurrentPreset();
        const currentMode = this._getCurrentMode();
        const marginTop = preset.map_source.crop?.top ?? 0;
        const marginBottom = preset.map_source.crop?.bottom ?? 0;
        const marginLeft = preset.map_source.crop?.left ?? 0;
        const marginRight = preset.map_source.crop?.right ?? 0;
        this._calculateBasicScale();
        if (!currentMode || this.selectedManualRectangles.length >= currentMode.maxSelections) {
            forwardHaptic("failure");
            return;
        }
        const actualHeight = this.realImageHeight * this.realScale - marginTop - marginBottom;
        const actualWidth = this.realImageWidth * this.realScale - marginLeft - marginRight;
        const name = (this.selectedManualRectangles.length + 1).toString();
        const x = (actualWidth / 3 + marginLeft - this.mapX) / this.mapScale;
        const y = (actualHeight / 3 + marginTop - this.mapY) / this.mapScale;
        const width = actualWidth / 3 / this.mapScale;
        const height = actualHeight / 3 / this.mapScale;
        this.selectedManualRectangles.push(new ManualRectangle(x, y, width, height, name, this._getContext()));
        this._selectionChanged();
        forwardHaptic("selection");
        this.requestUpdate();
    }

    private _mouseDown(event: PointerEvent | MouseEvent | TouchEvent): void {
        if (event instanceof MouseEvent && event.button != 0) {
            return;
        }
        this.shouldHandleMouseUp = true;
    }

    private _mouseMove(event: MouseEvent | TouchEvent): void {
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        if ((<Element>event.target).classList.contains("draggable")) {
            return;
        }
        this.selectedManualRectangles.filter(r => r.isSelected()).forEach(r => r.externalDrag(event));
        this.shouldHandleMouseUp = false;
    }

    private _mouseUp(event: PointerEvent | MouseEvent | TouchEvent): void {
        const currentMode = this._getCurrentMode();
        if (!(event instanceof MouseEvent && event.button != 0) && this.shouldHandleMouseUp && currentMode) {
            const { x, y } = getMousePosition(event, this._getSvgWrapper(), 1);
            switch (currentMode.selectionType) {
                case SelectionType.MANUAL_PATH:
                    forwardHaptic("selection");
                    this.selectedManualPath.addPoint(x, y);
                    this._selectionChanged();
                    break;
                case SelectionType.MANUAL_POINT:
                    forwardHaptic("selection");
                    this.selectedManualPoint = new ManualPoint(x, y, this._getContext());
                    this._selectionChanged();
                    break;
                default:
                    return;
            }
            stopEvent(event);
            this.requestUpdate();
        }
        this.shouldHandleMouseUp = false;
    }

    private _handleRunAction(): ActionHandlerFunction {
        return async (ev?: ActionHandlerEvent): Promise<void> => {
            if (this.hass && ev?.detail?.action) {
                switch (ev.detail.action) {
                    case "tap":
                        await this._run(false);
                        break;
                    case "hold":
                        await this._run(true);
                        break;
                    case "double_tap":
                        console.log(
                            JSON.stringify(
                                {
                                    ...this._getCurrentPreset(),
                                    additional_presets: undefined,
                                    title: undefined,
                                    type: undefined,
                                },
                                null,
                                2,
                            ),
                        );
                        window.alert("Configuration available in browser's console");
                        forwardHaptic("success");
                        break;
                }
            }
        };
    }

    private _restoreMap(): void {
        const zoomerContent = this._getMapZoomerContent();
        zoomerContent.style.transitionDuration = this._getCssProperty("--map-card-internal-transitions-duration");
        this._getPinchZoom().setTransform({ scale: 1, x: 0, y: 0, allowChangeEvent: true });
        this.mapScale = 1;
        forwardHaptic("selection");
        delay(300).then(() => (zoomerContent.style.transitionDuration = "0s"));
    }

    private _getCssProperty(property: string): string {
        return getComputedStyle(this._getMapImage()).getPropertyValue(property);
    }

    private _zoomIn(): void {
        forwardHaptic("selection");
        this._updateScale(1.5);
    }

    private _zoomOut(): void {
        forwardHaptic("selection");
        this._updateScale(1 / 1.5);
    }

    private _updateScale(diff: number): void {
        const zoomerContent = this._getMapZoomerContent();
        const pinchZoom = this._getPinchZoom();
        const zoomerRect = this._getPinchZoom().getBoundingClientRect();
        this.mapScale = Math.max(this.mapScale * diff, 0.5);
        zoomerContent.style.transitionDuration = "200ms";
        pinchZoom.scaleTo(this.mapScale, {
            originX: zoomerRect.left + zoomerRect.width / 2,
            originY: zoomerRect.top + zoomerRect.height / 2,
            relativeTo: "container",
            allowChangeEvent: true,
        });
        delay(300).then(() => (zoomerContent.style.transitionDuration = "0s"));
    }

    private _isSameViewbox(viewBox: DOMRect): boolean {
        if (this.mapViewBox === undefined) return false;
        for (const f in ["x", "y", "width", "height"]) {
            if (viewBox[f] !== this.mapViewBox[f]) return false
        }
        return true;
    }

    private _isSvgMapImage(): boolean {
        return !!this.internalVariables['svgmap'];
    }

    private _updateSvgImageSize(): void {
        const mapObject = this._getMapObject();

        if (mapObject.contentDocument?.documentElement.nodeName !== 'svg') {
            this.mapViewBox = undefined;
            return;
        }

        const viewBoxRect = (mapObject.contentDocument.documentElement as unknown as SVGSVGElement).viewBox.baseVal;
        if (this._isSameViewbox(viewBoxRect)) {
            return;
        }
        this.mapViewBox = viewBoxRect;

        this.realImageHeight = viewBoxRect.height;
        this.realImageWidth = viewBoxRect.width;
    }

    private _updateSimpleImageSize(): void {
        const mapImage = this._getMapImage();

        if (mapImage && mapImage.naturalWidth > 0) {
            this.realImageWidth = mapImage.naturalWidth;
            this.realImageHeight = mapImage.naturalHeight;
        }
    }

    private _getOffset(): Point | undefined {
        if (this.mapViewBox === undefined || (this.mapViewBox.x === 0 && this.mapViewBox.y === 0)) {
            return undefined;
        }
        return {x: -this.mapViewBox.x, y: -this.mapViewBox.y}
    }

    private _updateImageSizeAndScale(): void {
        if (this._isSvgMapImage()) {
            this._updateSvgImageSize();
        } else {
            this._updateSimpleImageSize();
        }

        this._calculateBasicScale();
    }

    private _calculateBasicScale(): void {
        const mapImage = this._getMapImage();

        if (mapImage && mapImage.offsetWidth && this.realImageWidth) {
            this.realScale = mapImage.offsetWidth / this.realImageWidth;
        } else {
            this.realScale = 1;
        }
    }

    private _calculateScale(): void {
        const pinchZoom = this._getPinchZoom();
        this.mapScale = pinchZoom.scale;
        this.mapX = pinchZoom.x;
        this.mapY = pinchZoom.y;
    }

    private _getPinchZoom(): PinchZoom {
        return this.shadowRoot?.getElementById("map-zoomer") as PinchZoom;
    }

    private _getMapObject(): HTMLObjectElement {
        return this.shadowRoot?.getElementById("map-object") as HTMLObjectElement;
    }

    private _getMapImage(): HTMLImageElement {
        return this.shadowRoot?.getElementById("map-image") as HTMLImageElement;
    }

    private _getMapZoomerContent(): HTMLElement {
        return this.shadowRoot?.getElementById("map-zoomer-content") as HTMLElement;
    }

    private _getSvgWrapper(): SVGGraphicsElement {
        return this.shadowRoot?.querySelector("#svg-wrapper") as SVGGraphicsElement;
    }

    private _showConfigErrors(errors: string[]): TemplateResult {
        errors.forEach(e => console.error(e));
        const errorCard = document.createElement("hui-error-card") as LovelaceCard;
        try {

            errorCard.setConfig({
                type: "error",
                error: errors[0],
                origConfig: this.config,
            });
            return html` ${errorCard} `;
        }
        catch {
            return html`
                <pre style="padding: 10px; background-color: red;">${errors[0]}</pre>
            `;
        }

    }

    private _showOldConfig(): TemplateResult {
        return html`
            <hui-warning>
                <h1>Xiaomi Vacuum Map Card ${CARD_VERSION}</h1>
                <p>${this._localize("common.old_configuration")}</p>
                <p>
                    <a
                        href="https://github.com/PiotrMachowski/lovelace-xiaomi-vacuum-map-card#migrating-from-v1xx"
                        target="_blank"
                        >${this._localize("common.old_configuration_migration_link")}</a
                    >
                </p>
            </hui-warning>
        `;
    }

    private _showInvalidEntities(entities: string[]): TemplateResult {
        return html`
            <hui-warning>
                <h1>${this._localize("validation.invalid_entities")}</h1>
                <ul>
                    ${entities.map(
                        e => html` <li>
                            <pre>${e}</pre>
                        </li>`,
                    )}
                </ul>
            </hui-warning>
        `;
    }

    private _showInvalidCalibrationWarning(): TemplateResult {
        return html` <hui-warning>${this._localize("validation.invalid_calibration")}</hui-warning> `;
    }

    private _localize(ts: TranslatableString): string {
        return localizeWithHass(ts, this.hass, this.config);
    }

    private _showToast(text: string, icon: string, successful: boolean, additionalText = ""): void {
        ToastRenderer.showToast(
            this.shadowRoot,
            v => this._localize(v),
            "map-card",
            text,
            icon,
            successful,
            additionalText,
        );
    }

    static get styles(): CSSResultGroup {
        return css`
            ha-card {
                overflow: hidden;
                display: flow-root;
                --map-card-internal-primary-color: var(--map-card-primary-color, var(--slider-color));
                --map-card-internal-primary-text-color: var(--map-card-primary-text-color, var(--primary-text-color));
                --map-card-internal-secondary-color: var(--map-card-secondary-color, var(--slider-secondary-color));
                --map-card-internal-secondary-text-color: var(
                    --map-card-secondary-text-color,
                    var(--text-light-primary-color)
                );
                --map-card-internal-tertiary-color: var(--map-card-tertiary-color, var(--secondary-background-color));
                --map-card-internal-tertiary-text-color: var(--map-card-tertiary-text-color, var(--primary-text-color));
                --map-card-internal-disabled-text-color: var(
                    --map-card-disabled-text-color,
                    var(--disabled-text-color)
                );
                --map-card-internal-zoomer-background: var(
                    --map-card-zoomer-background,
                    var(--map-card-internal-tertiary-color)
                );
                --map-card-internal-ripple-color: var(--map-card-ripple-color, #7a7f87);
                --map-card-internal-big-radius: var(--map-card-big-radius, 25px);
                --map-card-internal-small-radius: var(--map-card-small-radius, 18px);
                --map-card-internal-predefined-point-icon-wrapper-size: var(
                    --map-card-predefined-point-icon-wrapper-size,
                    36px
                );
                --map-card-internal-predefined-point-icon-size: var(--map-card-predefined-point-icon-size, 24px);
                --map-card-internal-predefined-point-icon-color: var(
                    --map-card-predefined-point-icon-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-predefined-point-icon-color-selected: var(
                    --map-card-predefined-point-icon-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-predefined-point-icon-background-color: var(
                    --map-card-predefined-point-icon-background-color,
                    var(--map-card-internal-secondary-color)
                );
                --map-card-internal-predefined-point-icon-background-color-selected: var(
                    --map-card-predefined-point-icon-background-color-selected,
                    var(--map-card-internal-primary-color)
                );
                --map-card-internal-predefined-point-label-color: var(
                    --map-card-predefined-point-label-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-predefined-point-label-color-selected: var(
                    --map-card-predefined-point-label-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-predefined-point-label-font-size: var(
                    --map-card-predefined-point-label-font-size,
                    12px
                );
                --map-card-internal-manual-point-radius: var(--map-card-manual-point-radius, 5px);
                --map-card-internal-manual-point-line-color: var(--map-card-manual-point-line-color, yellow);
                --map-card-internal-manual-point-fill-color: var(--map-card-manual-point-fill-color, transparent);
                --map-card-internal-manual-point-line-width: var(--map-card-manual-point-line-width, 1px);
                --map-card-internal-manual-path-point-radius: var(--map-card-manual-path-point-radius, 5px);
                --map-card-internal-manual-path-point-line-color: var(--map-card-manual-path-point-line-color, yellow);
                --map-card-internal-manual-path-point-fill-color: var(
                    --map-card-manual-path-point-fill-color,
                    transparent
                );
                --map-card-internal-manual-path-point-line-width: var(--map-card-manual-path-point-line-width, 1px);
                --map-card-internal-manual-path-line-color: var(--map-card-manual-path-line-color, yellow);
                --map-card-internal-manual-path-line-width: var(--map-card-manual-path-line-width, 1px);
                --map-card-internal-predefined-rectangle-line-width: var(
                    --map-card-predefined-rectangle-line-width,
                    1px
                );
                --map-card-internal-predefined-rectangle-line-color: var(
                    --map-card-predefined-rectangle-line-color,
                    white
                );
                --map-card-internal-predefined-rectangle-fill-color: var(
                    --map-card-predefined-rectangle-fill-color,
                    transparent
                );
                --map-card-internal-predefined-rectangle-line-color-selected: var(
                    --map-card-predefined-rectangle-line-color-selected,
                    white
                );
                --map-card-internal-predefined-rectangle-fill-color-selected: var(
                    --map-card-predefined-rectangle-fill-color-selected,
                    rgba(255, 255, 255, 0.2)
                );
                --map-card-internal-predefined-rectangle-line-segment-line: var(
                    --map-card-predefined-rectangle-line-segment-line,
                    10px
                );
                --map-card-internal-predefined-rectangle-line-segment-gap: var(
                    --map-card-predefined-rectangle-line-segment-gap,
                    5px
                );
                --map-card-internal-predefined-rectangle-icon-wrapper-size: var(
                    --map-card-predefined-rectangle-icon-wrapper-size,
                    36px
                );
                --map-card-internal-predefined-rectangle-icon-size: var(
                    --map-card-predefined-rectangle-icon-size,
                    24px
                );
                --map-card-internal-predefined-rectangle-icon-color: var(
                    --map-card-predefined-rectangle-icon-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-predefined-rectangle-icon-color-selected: var(
                    --map-card-predefined-rectangle-icon-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-predefined-rectangle-icon-background-color: var(
                    --map-card-predefined-rectangle-icon-background-color,
                    var(--map-card-internal-secondary-color)
                );
                --map-card-internal-predefined-rectangle-icon-background-color-selected: var(
                    --map-card-predefined-rectangle-icon-background-color-selected,
                    var(--map-card-internal-primary-color)
                );
                --map-card-internal-predefined-rectangle-label-color: var(
                    --map-card-predefined-rectangle-label-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-predefined-rectangle-label-color-selected: var(
                    --map-card-predefined-rectangle-label-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-predefined-rectangle-label-font-size: var(
                    --map-card-predefined-rectangle-label-font-size,
                    12px
                );
                --map-card-internal-manual-rectangle-line-width: var(--map-card-manual-rectangle-line-width, 1px);
                --map-card-internal-manual-rectangle-line-color: var(--map-card-manual-rectangle-line-color, white);
                --map-card-internal-manual-rectangle-fill-color: var(
                    --map-card-manual-rectangle-fill-color,
                    rgba(255, 255, 255, 0.2)
                );
                --map-card-internal-manual-rectangle-line-color-selected: var(
                    --map-card-manual-rectangle-line-color-selected,
                    white
                );
                --map-card-internal-manual-rectangle-fill-color-selected: var(
                    --map-card-manual-rectangle-fill-color-selected,
                    transparent
                );
                --map-card-internal-manual-rectangle-line-segment-line: var(
                    --map-card-manual-rectangle-line-segment-line,
                    10px
                );
                --map-card-internal-manual-rectangle-line-segment-gap: var(
                    --map-card-manual-rectangle-line-segment-gap,
                    5px
                );
                --map-card-internal-manual-rectangle-description-color: var(
                    --map-card-manual-rectangle-description-color,
                    white
                );
                --map-card-internal-manual-rectangle-description-font-size: var(
                    --map-card-manual-rectangle-description-font-size,
                    12px
                );
                --map-card-internal-manual-rectangle-description-offset-x: var(
                    --map-card-manual-rectangle-description-offset-x,
                    2px
                );
                --map-card-internal-manual-rectangle-description-offset-y: var(
                    --map-card-manual-rectangle-description-offset-y,
                    -8px
                );
                --map-card-internal-manual-rectangle-delete-circle-radius: var(
                    --map-card-manual-rectangle-delete-circle-radius,
                    13px
                );
                --map-card-internal-manual-rectangle-delete-circle-line-color: var(
                    --map-card-manual-rectangle-delete-circle-line-color,
                    white
                );
                --map-card-internal-manual-rectangle-delete-circle-fill-color: var(
                    --map-card-manual-rectangle-delete-circle-fill-color,
                    var(--map-card-internal-secondary-color)
                );
                --map-card-internal-manual-rectangle-delete-circle-line-color-selected: var(
                    --map-card-manual-rectangle-delete-circle-line-color-selected,
                    white
                );
                --map-card-internal-manual-rectangle-delete-circle-fill-color-selected: var(
                    --map-card-manual-rectangle-delete-circle-fill-color-selected,
                    var(--map-card-internal-primary-color)
                );
                --map-card-internal-manual-rectangle-delete-circle-line-width: var(
                    --map-card-manual-rectangle-delete-circle-line-width,
                    1px
                );
                --map-card-internal-manual-rectangle-delete-icon-color: var(
                    --map-card-manual-rectangle-delete-icon-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-manual-rectangle-delete-icon-color-selected: var(
                    --map-card-manual-rectangle-delete-icon-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-manual-rectangle-resize-circle-radius: var(
                    --map-card-manual-rectangle-resize-circle-radius,
                    13px
                );
                --map-card-internal-manual-rectangle-resize-circle-line-color: var(
                    --map-card-manual-rectangle-resize-circle-line-color,
                    white
                );
                --map-card-internal-manual-rectangle-resize-circle-fill-color: var(
                    --map-card-manual-rectangle-resize-circle-fill-color,
                    var(--map-card-internal-secondary-color)
                );
                --map-card-internal-manual-rectangle-resize-circle-line-color-selected: var(
                    --map-card-manual-rectangle-resize-circle-line-color-selected,
                    white
                );
                --map-card-internal-manual-rectangle-resize-circle-fill-color-selected: var(
                    --map-card-manual-rectangle-resize-circle-fill-color-selected,
                    var(--map-card-internal-primary-color)
                );
                --map-card-internal-manual-rectangle-resize-circle-line-width: var(
                    --map-card-manual-rectangle-resize-circle-line-width,
                    1px
                );
                --map-card-internal-manual-rectangle-resize-icon-color: var(
                    --map-card-manual-rectangle-resize-icon-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-manual-rectangle-resize-icon-color-selected: var(
                    --map-card-manual-rectangle-resize-icon-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-room-outline-line-color: var(--map-card-room-outline-line-color, white);
                --map-card-internal-room-outline-line-width: var(--map-card-room-outline-line-width, 1px);
                --map-card-internal-room-outline-line-segment-line: var(
                    --map-card-room-outline-line-segment-line,
                    10px
                );
                --map-card-internal-room-outline-line-segment-gap: var(--map-card-room-outline-line-segment-gap, 5px);
                --map-card-internal-room-outline-fill-color: var(--map-card-room-outline-fill-color, transparent);
                --map-card-internal-room-outline-line-color-selected: var(
                    --map-card-room-outline-line-color-selected,
                    white
                );
                --map-card-internal-room-outline-fill-color-selected: var(
                    --map-card-room-outline-fill-color-selected,
                    rgba(255, 255, 255, 0.3)
                );
                --map-card-internal-room-icon-wrapper-size: var(--map-card-room-icon-wrapper-size, 36px);
                --map-card-internal-room-icon-size: var(--map-card-room-icon-size, 24px);
                --map-card-internal-room-icon-color: var(
                    --map-card-room-icon-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-room-icon-color-selected: var(
                    --map-card-room-icon-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-room-icon-background-color: var(
                    --map-card-room-icon-background-color,
                    var(--map-card-internal-secondary-color)
                );
                --map-card-internal-room-icon-background-color-selected: var(
                    --map-card-room-icon-background-color-selected,
                    var(--map-card-internal-primary-color)
                );
                --map-card-internal-room-label-color: var(
                    --map-card-room-label-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-room-label-color-selected: var(
                    --map-card-room-label-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-room-label-font-size: var(--map-card-room-label-font-size, 12px);
                --map-card-internal-toast-successful-icon-color: var(
                    --map-card-toast-successful-icon-color,
                    rgb(0, 255, 0)
                );
                --map-card-internal-toast-unsuccessful-icon-color: var(
                    --map-card-toast-unsuccessful-icon-color,
                    rgb(255, 0, 0)
                );
                --map-card-internal-transitions-duration: var(--map-card-transitions-duration, 200ms);
            }

            .clickable {
                cursor: pointer;
            }

            .map-wrapper {
                position: relative;
                height: max-content;
            }

            #map-zoomer {
                overflow: hidden;
                display: block;
                --scale: 1;
                --x: 0;
                --y: 0;
                background: var(--map-card-internal-zoomer-background);
            }

            #map-zoomer-content {
                transform: translate(var(--x), var(--y)) scale(var(--scale));
                transform-origin: 0 0;
                position: relative;
            }

            #map-image {
                width: 100%;
                margin-bottom: -6px;
            }

            #map-image.zoomed {
                image-rendering: pixelated;
            }

            #map-image-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
            }

            .standalone-icon-on-map {
                background-color: var(--map-card-internal-secondary-color);
                color: var(--map-card-internal-secondary-text-color);
                border-radius: var(--map-card-internal-small-radius);
                margin: 5px;
                width: 36px;
                height: 36px;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .map-zoom-icons {
                right: 0;
                bottom: 0;
                position: absolute;
                display: inline-flex;
                background-color: var(--map-card-internal-secondary-color);
                color: var(--map-card-internal-secondary-text-color);
                border-radius: var(--map-card-internal-small-radius);
                margin: 5px;
                direction: ltr;
            }

            .map-zoom-icons-main {
                display: inline-flex;
                border-radius: var(--map-card-internal-small-radius);
                background-color: var(--map-card-internal-primary-color);
                color: var(--map-card-internal-primary-text-color);
            }

            .icon-on-map {
                touch-action: auto;
                pointer-events: auto;
                height: 36px;
                width: 36px;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .controls-wrapper {
                margin: 15px;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .map-controls {
                width: 100%;
                display: inline-flex;
                gap: 10px;
                place-content: space-between;
                flex-wrap: wrap;
            }

            .map-actions-list {
                border-radius: var(--map-card-internal-big-radius);
                overflow: hidden;
                background-color: var(--map-card-internal-secondary-color);
                color: var(--map-card-internal-secondary-text-color);
                margin-inline-start: auto;
                display: inline-flex;
                height: min-content;
            }

            .map-actions-item.main {
                border-radius: var(--map-card-internal-big-radius);
                background-color: var(--map-card-internal-primary-color);
                color: var(--map-card-internal-primary-text-color);
            }

            .map-actions-item {
                width: 50px;
                height: 50px;
                display: flex;
                justify-content: center;
                align-items: center;
                background-color: transparent;
            }

            .ripple {
                position: relative;
                overflow: hidden;
                transform: translate3d(0, 0, 0);
            }

            .ripple:after {
                content: "";
                display: block;
                position: absolute;
                border-radius: 50%;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                pointer-events: none;
                background-image: radial-gradient(circle, var(--map-card-internal-ripple-color) 2%, transparent 10.01%);
                background-repeat: no-repeat;
                background-position: 50%;
                transform: scale(10, 10);
                opacity: 0;
                transition: transform 0.5s, opacity 1s;
            }

            .ripple:active:after {
                transform: scale(0, 0);
                opacity: 0.7;
                transition: 0s;
            }

            ${PresetSelector.styles}
            ${MapObject.styles}
            ${ManualRectangle.styles}
            ${PredefinedMultiRectangle.styles}
            ${ManualPath.styles}
            ${ManualPoint.styles}
            ${PredefinedPoint.styles}
            ${Room.styles}
            ${IconsWrapper.styles}
            ${TilesWrapper.styles}
            ${DropdownMenu.styles}
            ${ToastRenderer.styles}
        `;
    }
}
